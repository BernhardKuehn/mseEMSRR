# oem.R - DESC
# mse/R/oem.R

# Copyright European Union, 2018
# Author: Ernesto Jardim (EC JRC) <ernesto.jardim@ec.europa.eu>
#         Iago Mosqueira (EC JRC) <iago.mosqueira@ec.europa.eu>
#
# Distributed under the terms of the European Union Public Licence (EUPL) V.1.1.


# perfect.oem {{{

#' A perfect observation of catch and abundances-at-age.
#'
#' This observation error model function generates a set of perfect observations
#' on catches, biology and abundance. Direct observations are made of the stock,
#' while a single age-structured index of abundance, in numbers, is created with
#' a fixed catchability of 0.01. *deviances* on either *stk$catch.n* or
#' *idx$index*, if given, are applied.
#'
#' This *oem* function generates a full observation time series every time step,
#' and does not append them to existing objects in *observations*.
#'
#' @param om An operating model, class *FLom* or *FLombf*.
#' @param observations A list of past observations, extended to the end of *om*, class *list*.
#' @param deviances A named list of observation deviances, class *list*.
#' @param args The mp dimensions arguments, as generated by `mp`, class *list*.
#' @param tracking Object to track module decisions and outputs, class *FLQuant*.
#'
#' @return A named *list* with elements *stk* (*FLStock*), *idx* (*FLIndices*), *deviances*, *observations* and *tracking*.
#'
#' @examples
#' # On FLom
#' data(ple4om)
#' obs <- perfect.oem(om, deviances=NULL, observations=NULL,
#'   args=list(y0=1957, dy=2017), tracking=FLQuant())

perfect.oem <- function(om, deviances, observations, args, tracking, ...) {

  # DIMENSIONS
  y0 <- ac(args$y0)
  dy <- ac(args$dy)

  # GET perfect stock
	stk <- window(stock(om), start=y0, end=dy, extend=FALSE)

  # SET perfect at-age FLIndex per stock
  # TODO GET name from observations
  idx <- FLIndices(A=FLIndex(index=stock.n(stk) * 0.01,
    catch.n=catch.n(stk), catch.wt=stock.wt(stk),
    sel.pattern=catch.sel(stk), index.q=stock.n(stk) %=% 1 / 0.01,
    effort=fbar(stk), range=c(startf=0, endf=0)))

  # STORE observations
  observations$stk <- stk
  observations$idx <- idx

	list(stk=stk, idx=idx, observations=observations, tracking=tracking)

} # }}}

# sampling.oem {{{

#' @examples
#' data(ple4om)
#' oem@deviances$idx <- lapply(oem@observations$idx, function(x) index(x) %=% 0.1)
#' oem@deviances$stk <- FLQuants(catch.n=catch.n(stock(om)) %=% 0.1)
#' oem@observations$idx[[1]] <- propagate(oem@observations$idx[[1]], 25)
#' sampling.oem(om, deviances=deviances(oem), observations=observations(oem),
#'   args=list(y0=2000, dy=2021, ay=2022, frq=1), tracking=FLQuant(), oe="both")

sampling.oem <- function(om, deviances, observations, args, tracking,
  oe=c("both","index","catch"), ...) {

  # CHECK necessary deviances
  if(any(oe %in% c("both", "catch")) & ! "stk" %in% names(deviances))
    stop(paste("sampling.oem requires deviances for 'stk' if oe = ", oe))
  
  if(any(oe %in% c("both", "index")) & ! "idx" %in% names(deviances))
    stop(paste("sampling.oem requires deviances for 'idx' if oe = ", oe))
  
  # DIMENSIONS
  y0 <- ac(args$y0)
  dy <- ac(args$dy)
  yrs <- ac(seq(args$y0, args$dy))

  # Data years
  dyrs <- ac(seq(args$dy - args$frq + 1, args$dy))

  # Assessment year
  ay <- ac(args$ay)

  # GET perfect stock
	stk <- window(stock(om), start=y0, end=dy, extend=FALSE)
  
  # STK: catch.n
  if(any(oe %in% c("both","catch"))) {

    # ADD 1 individual to avoid some methods crashing on 0s
    catch.n(observations$stk)[, dyrs] <- catch.n(stk)[, dyrs] *
      deviances$stk$catch.n[, dyrs] + 1
    
    # TODO landings and discards
    #landings.n(observations$stk)[, dyrs] <- landings.n(stk)[, dyrs] *
    #  deviances$stk$landings.n[, dyrs] + 1
    # landings(observations$stk)[, dyrs] <- computeLandings(observations$stk[, dyrs])

    #discards.n(observations$stk)[, dyrs] <- discards.n(stk)[, dyrs] *
    #  deviances$stk$discards.n[, dyrs] + 1
    # discards(observations$stk)[, dyrs] <- computeDiscards(observations$stk[, dyrs])

    catch(observations$stk)[, dyrs] <- computeCatch(observations$stk[, dyrs])

    # SHORTCUT 
    stock.n(observations$stk)[, dyrs] <- stock.n(stk)[, dyrs]
    harvest(observations$stk)[, dyrs] <- harvest(stk)[, dyrs]

    # SET output stock
    stk0 <- observations$stk[, yrs]

  } else {
    stk0 <- stk[, yrs]
  }

  # IDX: indices, index.q
  if(any(oe %in% c("both","indices"))) {
    
    idx <- observations$idx

    # CHOOSE indices to be updated (maxyear >= dy)
    upi <- unlist(lapply(idx, function(x) range(x, "maxyear") > args$dy))

    # APPLY survey() with deviances$idx as index.q

    idx[upi] <- Map(function(x, y) {

      res <- survey(stk[, dyrs], x[, dyrs], sel=sel.pattern(x)[, dyrs],
        index.q=y[, dyrs])
    
      # SET 0s to min / 2
      res[res == 0] <- min(res[res > 0] / 2)

      # ASSIGN in dyrs    
      index(x)[, dyrs] <- res

      return(x)

    }, x=idx[upi], y=deviances$idx[upi])

    observations$idx <- idx

  } else {
    idx <- observations$idx
  }

  # return
  list(stk=stk0, idx=idx, observations=observations, tracking=tracking)

} # }}}

# default.oem {{{
default.oem <- function(om) {
  
  # observations match OM
  obs <- list(idx=FLIndices(A=as(stock(om), 'FLIndex')), stk=stock(om))

  # deviances are NULL
  devs <- list(idx=FLQuants(index.q=index.q(obs$idx$A) %=% 1),
    stk=FLQuants(catch.n=catch.n(obs$stk) %=% 1))

  # method is perfect.oem

  return(FLoem(method=perfect.oem, observations=obs, deviances=devs))
}
# }}}
