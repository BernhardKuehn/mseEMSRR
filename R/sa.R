# sa.R - DESC
# /sa.R

# Copyright European Union, 2018
# Author: Iago Mosqueira (EC JRC) <iago.mosqueira@ec.europa.eu>
#
# Distributed under the terms of the European Union Public Licence (EUPL) V.1.1.

# perfect.sa {{{


#' A perfect 'estimate' of abundances, catches and harvest.
#'
#' The *FLStock* generated by the call to *oem* is simply passed on in this
#' function. The estimates of abundance, catches and exploitation will thus be
#' as precise as the OEM observation.
#'
#' @param stk The stock observation generated by *oem*. Class *FLStock*.
#' @param idx An observation of chnages in abundance, not used. Class *FLIndices*.
#' @param args MSE arguments, class *list*.
#' @param tracking Structure for tracking modules outputs.
#'
#' @return A *list* with elements *stk* and *tracking*.
#'
#' @examples
#' data(ple4om)
#' perfect.sa(stock(om), FLIndices(), args=list(ay=2018, dy=2017),
#'   tracking=FLQuants(FLQuant(dimnames=list(metric="conv.est", year=2018))))

perfect.sa <- function(stk, idx, args, tracking, ...) {
 
  stk <- window(stk, end=args$dy)
  
  track(tracking, "conv.est", ac(args$ay)) <- 1
  
  list(stk=stk, tracking=tracking)
}
# }}}

# mlc.ind

# cpue.ind

# mean length of the catch - length based estimator
mlc.est <- function (stk, idx, args, vbPars=c(linf=120, k=0.2, t0=0), ...) {
  
  args0 <- list(...)
  tracking <- args0$tracking

  # 
	vbObj <- a4aGr(
	  grMod=~linf*(1 - exp(-k * (t - t0))),      
	  grInvMod=~t0 - 1/k * log(1 - len / linf),      
	  params=FLPar(linf=vbPars["linf"], k=vbPars["k"], t0=vbPars["t0"],
      units=c('cm','year-1','year')))
	
  flq <- flc <- catch.n(stk)
	flq[] <- predict(vbObj, t=range(stk)["min"]:range(stk)["max"] + 0.5)
	flq <- quantSums(flc * flq) / quantSums(flc)
	
  attr(stk, "indicator") <- flq
  
  tracking["indicator.est", ac(args$ay)] <- flq[,ac(args$dy)]
  
  list(stk = stk, tracking = tracking)
}
