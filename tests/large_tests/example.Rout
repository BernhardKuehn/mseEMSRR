
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # example.R - DESC
> # mse/tests/example.R
> 
> # Copyright European Union, 2018
> # Authors: Finlay Scott (EC JRC)
> #          Ernesto Jardim (EC JRC) <ernesto.jardim@ec.europa.eu>
> #          Iago Mosqueira (EC JRC) <iago.mosqueira@ec.europa.eu>
> #
> # Distributed under the terms of the European Union Public Licence (EUPL) V.1.1.
> 
> # ==============================================================================
> # SETUP
> # ==============================================================================
> 
> # LOAD packages
> 
> library(mse)
Loading required package: FLCore
Loading required package: lattice
Loading required package: iterators
FLCore (Version 2.6.14, packaged: 2019-11-18 21:54:10 UTC)
Loading required package: ggplotFL
Loading required package: ggplot2

Attaching package: ‘ggplot2’

The following object is masked from ‘package:FLCore’:

    %+%

Loading required package: data.table
Loading required package: FLash
Loading required package: FLBRP
Warning message:
replacing previous import ‘ggplot2::%+%’ by ‘FLCore::%+%’ when loading ‘ggplotFL’ 
> library(FLa4a)
Loading required package: triangle
Loading required package: copula
Loading required package: coda
Loading required package: grid
Loading required package: gridExtra

Attaching package: ‘gridExtra’

The following object is masked from ‘package:FLCore’:

    combine

Loading required package: latticeExtra
Loading required package: RColorBrewer

Attaching package: ‘latticeExtra’

The following object is masked from ‘package:ggplot2’:

    layer

This is FLa4a 1.8.1. For overview type 'help(package="FLa4a")'

> library(ggplotFL)
> library(doParallel)
Loading required package: foreach
Loading required package: parallel
> 
> # LOAD data
> 
> data(ple4)
> data(ple4.indices)
> 
> stk <- ple4
> idx <- ple4.indices["BTS-Combined (all)"]
> 
> # VARIABLES
> 
> it <- 25 # iterations
> fy <- 2030 # final year
> y0 <- range(stk)["minyear"] # initial OM year
> dy <- range(stk)["maxyear"] # final OM year
> iy <- dy # initial year of projection (also intermediate)
> #ny <- fy - iy + 1 # number of years to project from initial year
> nsqy <- 3 # number of years to compute status quo metrics
> vy <- ac(iy:fy) # vector of years to be projected
> 
> mpargs <- list(fy=fy, y0=y0, iy=iy, nsqy=nsqy)
> 
> # ==============================================================================
> # OM conditioning
> # ==============================================================================
> 
> # - Two SRRs: geomean and Bevholt
> 
> mcsave <- 500
> mcmc <- mcsave*it
> 
> fit <- sca(stk, idx, fit="MCMC", mcmc = SCAMCMC(mcmc = mcmc, mcsave = mcsave, mcprobe = 0.4))
> 
> stk <- stk + fit
> 
> # skin to keep one iteration
> stk0 <- qapply(stk, iterMedians)
> 
> # Fit a4a model to replicate official assessment w/MCMC
> 
> # average recruitment estimation sd
> rv1 <- sqrt(mean(c(iterVars(log(rec(stk)))), na.rm=TRUE))
> 
> # average autocor lag1
> # TODO acf(residuals)
> ac1 <- mean(apply(window(rec(stk), end=2008)@.Data, 6, function(x)
+   c(acf(c(x), plot=FALSE, lag.max=1)$acf[2])))
> 
> # BevHolt
> srbh <- fmle(as.FLSR(stk0, model="bevholt"), method="L-BFGS-B", lower=c(1e-6, 1e-6), upper=c(max(rec(stk)) * 3, Inf))
final  value -16.347176 
converged
> 
> # Residuals
> resbh <- ar1rlnorm(rho=ac1, years=dy:fy, iters=it, margSD=rv1*2)
> residuals(srbh) <- resbh
> 
> # ==============================================================================
> # Refpts
> # ==============================================================================
> 
> brp <- brp(FLBRP(stk0, srbh))
> 
> # ==============================================================================
> # Set up operating model
> # ==============================================================================
> 
> # Set up future assumptions - means of 3 years
> stk <- fwdWindow(stk, brp, end=2030)
> 
> #==============================================================================
> # Fleet behaviour
> #==============================================================================
> 
> fb <- mseCtrl(method=hyperstability.fb, args=list(beta=0.8))
> 
> #==============================================================================
> # OM projection method
> #==============================================================================
> 
> proj <- mseCtrl(method=fwd.om, args=list(maxF=2))
> 
> #==============================================================================
> # OM object
> #==============================================================================
> om <- FLom(stock=stk, sr=srbh, refpts=refpts(brp), projection=proj)#, fleetBehaviour=fb)
> 
> ###############################################################################
> # OEM settings
> ###############################################################################
> 
> #==============================================================================
> # prepare objects
> #==============================================================================
> 
> stk <- stock(om)
> 
> #==============================================================================
> # Estimate the indices catchability from the a4a fit (without simulation)
> #==============================================================================
> 
> set.seed(0)
> 
> # Use all indices
> idcs <- FLIndices()
> for (i in 1:length(idx)){
+ 	# this is a simplification as if index reflects 01 January abundances
+ 	lst <- mcf(list(idx[[i]]@index, stock.n(stk0)))
+ 	# log catchability of index 
+ 	idx.lq <- log(lst[[1]]/lst[[2]]) 
+ 	# empty quant
+ 	idx.qmu <- idx.qsig <- stock.n(iter(stk,1)) 
+ 	# Every year has the same mean catchability
+ 	idx.qmu[] <- yearMeans(idx.lq) 
+ 	idx.qsig[] <- sqrt(yearVars(idx.lq))
+ 	idx.q <- FLQuant(NA, dimnames=dimnames(stock.n(stk)))
+ 	# Build FLQ of index catchability based on lognormal distribution with mean and sd calculated above
+ 	idx.q <- rlnorm(it, idx.qmu, idx.qsig) 
+ 	#idx.q[,ac(y0:iy)] <- idx.q[,ac(y0:iy)]
+ 	idx_temp <- idx.q * stock.n(stk)
+ 	# generate initial index
+ 	idx_temp <- FLIndex(index=idx_temp, index.q=idx.q) 
+ 	range(idx_temp)[c("startf", "endf")] <- c(0, 0)
+ 	idcs[[i]] <- idx_temp
+ }
> names(idcs) <- names(idx)
> 
> #==============================================================================
> # Deviances for catch.n
> #==============================================================================
> 
> set.seed(0)
> 
> catch.dev <- log(catch.n(stk))
> catch.dev <- catch.dev-iterMeans(catch.dev)
> Sig <- apply(catch.dev[,ac(y0:dy),1,1,,drop=TRUE], 3, function(x) cov(t(x)))
> Sig <- apply(Sig, 1, mean)
> Sig <- matrix(Sig, ncol=dim(catch.dev)[1])
> catch.dev[,ac(vy)][] <- t(mvrnorm(it * length(vy), rep(0, nrow(Sig)), Sig))
> catch.dev <- exp(catch.dev)
> 
> #==============================================================================
> # OEM object
> #==============================================================================
> 
> idxDev <- lapply(idcs, index.q)
> names(idxDev) <- "index.q"
> stkDev <- FLQuants(catch.n=catch.dev)
> dev <- list(idx=idxDev, stk=stkDev)
> obs <- list(idx=idcs[1], stk=stk)
> 
> oem <- FLoem(method=sampling.oem, observations=obs, deviances=dev)
> #save(oem, file="oem.RData")
> 
> ###############################################################################
> # Implementation error
> ###############################################################################
> 
> iem <- FLiem(method=noise.iem, args=list(fun="rlnorm", mean=0, sd=0, multiplicative=TRUE))
> 
> ###############################################################################
> # Management procedure
> ###############################################################################
> 
> # general pars, add seed
> mpargs$seed <- 1234
> 
> #==============================================================================
> # Scenarios
> #==============================================================================
> 
> #------------------------------------------------------------------------------
> # base
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=FLQuant(0.3)))))
> 
> # run new method in single core without foreach
> resp1 <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with foreach
> registerDoParallel(1)
> resp1a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp1), stock(resp1a))
[1] TRUE
> 
> # run new method in 3 cores with foreach
> registerDoParallel(3)
> resp1b <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2022  > 2021  > 2022  > 2023  > 2022  > 2023  > 2024  > 2023  > 2024  > 2025  > 2024  > 2025  > 2026  > 2025  > 2026  > 2027  > 2026  > 2027  > 2028  > 2027  > 2028  > 2029  > 2028  > 2029  > 2029  > 2017  > 2017  > 2018  > 2017  > 2018  > 2019  > 2018  > 2019  > 2020  > 2019  > 2020  > 2021  > 2020  > 2021  > 2022  > 2021  > 2022  > 2023  > 2022  > 2023  > 2024  > 2023  > 2024  > 2025  > 2024  > 2025  > 2026  > 2025  > 2026  > 2027  > 2026  > 2027  > 2028  > 2027  > 2028  > 2029  > 2028  > 2029  > 2017  > 2029  > 2017  > 2018  > 2017  > 2018  > 2019  > 2018  > 2019  > 2020  > 2019  > 2020  > 2021  > 2020  > 2021  > 2022  > 2021  > 2022  > 2023  > 2022  > 2023  > 2024  > 2023  > 2024  > 2025  > 2024  > 2025  > 2026  > 2025  > 2026  > 2027  > 2026  > 2027  > 2028  > 2027  > 2028  > 2029  > 2028  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp1), stock(resp1b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(
+ 	ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is)))
> 
> # test parallel
> # run new method in single core without foreach
> resp2 <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with sequential foreach
> registerDoParallel(1)
> resp2a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp2), stock(resp2a))
[1] TRUE
> 
> # run new method in 2 cores with foreach
> registerDoParallel(3)
> resp2b <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2018  > 2017  > 2018  > 2019  > 2018  > 2019  > 2020  > 2019  > 2020  > 2021  > 2020  > 2021  > 2022  > 2021  > 2022  > 2023  > 2022  > 2023  > 2024  > 2023  > 2024  > 2025  > 2024  > 2025  > 2026  > 2025  > 2026  > 2027  > 2026  > 2027  > 2028  > 2027  > 2028  > 2029  > 2028  > 2029  > 2017  > 2029  > 2017  > 2018  > 2017  > 2018  > 2019  > 2018  > 2019  > 2020  > 2019  > 2020  > 2021  > 2020  > 2021  > 2022  > 2021  > 2022  > 2023  > 2022  > 2023  > 2024  > 2023  > 2024  > 2025  > 2024  > 2025  > 2026  > 2025  > 2026  > 2027  > 2026  > 2027  > 2028  > 2027  > 2028  > 2029  > 2028  > 2029  > 2017  > 2029  > 2017  > 2018  > 2017  > 2018  > 2019  > 2018  > 2019  > 2020  > 2019  > 2020  > 2021  > 2020  > 2021  > 2022  > 2021  > 2022  > 2023  > 2022  > 2023  > 2024  > 2023  > 2024  > 2025  > 2024  > 2025  > 2026  > 2025  > 2026  > 2027  > 2026  > 2027  > 2028  > 2027  > 2028  > 2029  > 2028  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp2), stock(resp2b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and SA
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=sca.sa)))
> 
> # test parallel
> # run new method in single core without foreach
> resp3 <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2019  > 2019  > 2020  > 2020  > 2021  > 2021  > 2018  > 2022  > 2022  > 2023  > 2023  > 2024  > 2019  > 2024  > 2025  > 2020  > 2025  > 2026  > 2021  > 2026  > 2027  > 2027  > 2028  > 2022  > 2023  > 2028  > 2029  > 2024  > 2029  > 2017  > 2025  > 2017  > 2026  > 2027  > 2018  > 2018  > 2028  > 2019  > 2029  > 2019  > 2017  > 2020  > 2020  > 2021  > 2021  > 2022  > 2022  > 2018  > 2023  > 2023  > 2019  > 2024  > 2024  > 2020  > 2025  > 2025  > 2021  > 2026  > 2026  > 2022  > 2027  > 2027  > 2023  > 2028  > 2028  > 2024  > 2029  > 2029  > 2025  > 2017  > 2026  > 2017  > 2027  > 2028  > 2029  > 2018  > 2017  > 2019  > 2018  > 2019  > 2018  > 2020  > 2021  > 2019  > 2022  > 2020  > 2023  > 2021  > 2024  > 2022  > 2025  > 2023  > 2026  > 2020  > 2024  > 2027  > 2021  > 2025  > 2028  > 2022  > 2026  > 2029  > 2023  > 2027  > 2024  > 2017  > 2028  > 2025  > 2018  > 2029  > 2026  > 2017  > 2019  > 2027  > 2020  > 2028  > 2021  > 2018  > 2029  > 2022  > 2017  > 2019  > 2023  > 2020  > 2024  > 2021  > 2025  > 2018  > 2022  > 2026  > 2023  > 2027  > 2024  > 2028  > 2025  > 2029  > 2026  > 2017  > 2027  > 2019  > 2028  > 2020  > 2029  > 2021  > 2017  > 2022  > 2023  > 2018  > 2024  > 2019  > 2025  > 2026  > 2018  > 2027  > 2019  > 2028  > 2020  > 2029  > 2021  > 2017  > 2020  > 2022  > 2021  > 2023  > 2022  > 2018  > 2024  > 2023  > 2019  > 2025  > 2024  > 2020  > 2026  > 2025  > 2021  > 2027  > 2026  > 2022  > 2028  > 2027  > 2023  > 2029  > 2028  > 2024  > 2017  > 2029  > 2025  > 2017  > 2026  > 2018  > 2027  > 2018  > 2028  > 2019  > 2029  > 2020  > 2017  > 2021  > 2018  > 2022  > 2023  > 2024  > 2019  > 2025  > 2020  > 2026  > 2021  > 2027  > 2019  > 2022  > 2028  > 2020  > 2023  > 2029  > 2021  > 2024  > 2017  > 2022  > 2025  > 2023  > 2026  > 2024  > 2027  > 2025  > 2018  > 2028  > 2026  > 2019  > 2029  > 2027  > 2020  > 2017  > 2028  > 2021  > 2029  > 2018  > 2022  > 2017  > 2023  > 2019  > 2024  > 2020  > 2025  > 2021  > 2026  > 2018  > 2022  > 2027  > 2019  > 2023  > 2028  > 2024  > 2020  > 2029  > 2021  > 2025  > 2022  > 2017  > 2026  > 2023  > 2027  > 2024  > 2028  > 2025  > 2029  > 2026  > 2017  > 2027  > 2028  > 2029  > 2017  > 2018  > 2018  > 2019  > 2018  > 2019  > 2020  > 2019  > 2020  > 2021  > 2020  > 2021  > 2022  > 2022  > 2023  > 2021  > 2024  > 2023  > 2022  > 2025  > 2024  > 2023  > 2026  > 2025  > 2024  > 2027  > 2026  > 2025  > 2028  > 2027  > 2026  > 2029  > 2028  > 2027  > 2029  > 2028  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with sequential foreach
> registerDoParallel(1)
> resp3a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp3), stock(resp3a))
[1] "Attributes: < Component “catch”: Mean relative difference: 1.800343e-08 >"     
[2] "Attributes: < Component “catch.n”: Mean relative difference: 2.026939e-08 >"   
[3] "Attributes: < Component “discards”: Mean relative difference: 1.736786e-08 >"  
[4] "Attributes: < Component “discards.n”: Mean relative difference: 1.962755e-08 >"
[5] "Attributes: < Component “harvest”: Mean relative difference: 2.031832e-08 >"   
[6] "Attributes: < Component “landings”: Mean relative difference: 1.738322e-08 >"  
[7] "Attributes: < Component “landings.n”: Mean relative difference: 2.019702e-08 >"
> 
> # run new method in 2 cores with foreach
> registerDoParallel(3)
> resp3b <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2019  > 2019  > 2020  > 2020  > 2021  > 2021  > 2018  > 2022  > 2022  > 2023  > 2023  > 2024  > 2019  > 2024  > 2025  > 2025  > 2020  > 2026  > 2026  > 2021  > 2027  > 2027  > 2028  > 2022  > 2023  > 2028  > 2029  > 2024  > 2029  > 2017  > 2025  > 2017  > 2026  > 2027  > 2018  > 2018  > 2028  > 2019  > 2029  > 2019  > 2020  > 2017  > 2020  > 2021  > 2021  > 2022  > 2022  > 2018  > 2023  > 2023  > 2019  > 2024  > 2024  > 2020  > 2025  > 2025  > 2021  > 2026  > 2026  > 2022  > 2027  > 2027  > 2023  > 2028  > 2028  > 2024  > 2029  > 2029  > 2025  > 2017  > 2026  > 2017  > 2027  > 2028  > 2029  > 2018  > 2017  > 2019  > 2018  > 2019  > 2018  > 2020  > 2021  > 2019  > 2022  > 2020  > 2023  > 2021  > 2024  > 2022  > 2025  > 2023  > 2020  > 2026  > 2024  > 2021  > 2027  > 2022  > 2025  > 2028  > 2023  > 2026  > 2029  > 2024  > 2027  > 2017  > 2028  > 2025  > 2029  > 2018  > 2026  > 2027  > 2017  > 2019  > 2028  > 2020  > 2029  > 2021  > 2018  > 2017  > 2022  > 2019  > 2023  > 2020  > 2024  > 2021  > 2025  > 2018  > 2022  > 2026  > 2023  > 2027  > 2024  > 2028  > 2025  > 2029  > 2026  > 2017  > 2019  > 2027  > 2028  > 2020  > 2029  > 2021  > 2017  > 2022  > 2023  > 2018  > 2024  > 2025  > 2019  > 2026  > 2018  > 2027  > 2028  > 2019  > 2029  > 2020  > 2017  > 2021  > 2020  > 2022  > 2021  > 2018  > 2023  > 2022  > 2024  > 2023  > 2019  > 2025  > 2024  > 2020  > 2026  > 2025  > 2021  > 2027  > 2026  > 2022  > 2028  > 2027  > 2023  > 2029  > 2028  > 2024  > 2017  > 2025  > 2029  > 2026  > 2017  > 2018  > 2027  > 2018  > 2028  > 2029  > 2019  > 2017  > 2020  > 2021  > 2018  > 2022  > 2023  > 2024  > 2019  > 2025  > 2020  > 2026  > 2021  > 2027  > 2019  > 2022  > 2028  > 2020  > 2023  > 2021  > 2029  > 2024  > 2022  > 2017  > 2025  > 2023  > 2026  > 2024  > 2027  > 2025  > 2018  > 2026  > 2028  > 2019  > 2027  > 2029  > 2020  > 2028  > 2017  > 2029  > 2021  > 2018  > 2022  > 2017  > 2023  > 2019  > 2024  > 2020  > 2025  > 2021  > 2018  > 2026  > 2022  > 2019  > 2027  > 2023  > 2020  > 2028  > 2024  > 2021  > 2029  > 2025  > 2022  > 2017  > 2026  > 2023  > 2027  > 2024  > 2028  > 2025  > 2026  > 2029  > 2027  > 2017  > 2028  > 2029  > 2017  > 2018  > 2018  > 2019  > 2018  > 2019  > 2020  > 2020  > 2019  > 2021  > 2021  > 2020  > 2022  > 2022  > 2023  > 2021  > 2023  > 2024  > 2022  > 2024  > 2025  > 2023  > 2025  > 2026  > 2024  > 2026  > 2027  > 2025  > 2027  > 2028  > 2026  > 2028  > 2029  > 2027  > 2029  > 2028  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp3), stock(resp3b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and IEM
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is)))
> 
> # test parallel
> # run new method in single core without foreach
> resp4 <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with sequential foreach
> registerDoParallel(1)
> resp4a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp4), stock(resp4a))
[1] TRUE
> 
> # run new method in 2 cores with foreach
> registerDoParallel(3)
> resp4b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp4), stock(resp4b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and SA and OEM and IEM
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=sca.sa),
+ 	ctrl.tm = mseCtrl(method=mpa.tm, args=list(sel.objective=FLModelSim(model=~1/(1+exp(-(a+b*x))), params=FLPar(a=-10, b=5))))))
> 
> # test parallel
> # run new method in single core without foreach
> resp5 <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
20172017   >  > 2017  > 2018  > 2018  > 2019  > 2019  > 2020  > 2020  > 2021  > 2021  > 2018  > 2022  > 2022  > 2023  > 2023  > 2024  > 2019  > 2024  > 2025  > 2020  > 2025  > 2026  > 2021  > 2027  > 2026  > 2022  > 2028  > 2027  > 2023  > 2029  > 2028  > 2024  > 2029  > 2017  > 2025  > 2017  > 2026  > 2027  > 2018  > 2028  > 2018  > 2029  > 2019  > 2019  > 2017  > 2020  > 2021  > 2022  > 2018  > 2023  > 2024  > 2019  > 2025  > 2020  > 2026  > 2021  > 2022  > 2027  > 2020  > 2023  > 2028  > 2024  > 2021  > 2029  > 2022  > 2025  > 2017  > 2023  > 2026  > 2024  > 2027  > 2025  > 2028  > 2026  > 2029  > 2027  > 2017  > 2028  > 2029  > 2018  > 2017  > 2018  > 2019  > 2019  > 2020  > 2018  > 2021  > 2022  > 2019  > 2023  > 2020  > 2024  > 2021  > 2022  > 2025  > 2023  > 2020  > 2026  > 2024  > 2021  > 2027  > 2025  > 2022  > 2026  > 2028  > 2023  > 2027  > 2024  > 2029  > 2028  > 2025  > 2017  > 2029  > 2026  > 2027  > 2017  > 2018  > 2028  > 2029  > 2019  > 2017  > 2020  > 2018  > 2021  > 2018  > 2022  > 2019  > 2023  > 2024  > 2020  > 2025  > 2021  > 2019  > 2026  > 2022  > 2020  > 2027  > 2023  > 2021  > 2028  > 2024  > 2022  > 2029  > 2025  > 2023  > 2026  > 2017  > 2027  > 2024  > 2018  > 2025  > 2028  > 2026  > 2029  > 2019  > 2027  > 2017  > 2020  > 2028  > 2021  > 2022  > 2029  > 2023  > 2017  > 2024  > 2025  > 2018  > 2026  > 2027  > 2019  > 2028  > 2020  > 2018  > 2029  > 2021  > 2019  > 2022  > 2017  > 2020  > 2023  > 2018  > 2021  > 2024  > 2022  > 2025  > 2019  > 2023  > 2026  > 2020  > 2027  > 2024  > 2021  > 2028  > 2025  > 2022  > 2026  > 2029  > 2023  > 2027  > 2024  > 2017  > 2028  > 2025  > 2018  > 2026  > 2029  > 2027  > 2017  > 2028  > 2018  > 2029  > 2017  > 2019  > 2020  > 2021  > 2018  > 2022  > 2019  > 2023  > 2020  > 2024  > 2021  > 2025  > 2019  > 2022  > 2026  > 2023  > 2027  > 2024  > 2028  > 2025  > 2029  > 2026  > 2017  > 2027  > 2028  > 2029  > 2018  > 2017  > 2020  > 2019  > 2021  > 2020  > 2022  > 2021  > 2023  > 2022  > 2024  > 2023  > 2025  > 2024  > 2026  > 2025  > 2027  > 2026  > 2028  > 2018  > 2027  > 2029  > 2028  > 2017  > 2029  > 2018  > 2017  > 2019  > 2019  > 2020  > 2020  > 2018  > 2021  > 2021  > 2022  > 2022  > 2023  > 2023  > 2019  > 2024  > 2024  > 2020  > 2025  > 2025  > 2021  > 2026  > 2026  > 2022  > 2027  > 2027  > 2023  > 2028  > 2028  > 2024  > 2029  > 2029  > 2025  > 2017  > 2026  > 2027  > 2028  > 2029  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with sequential foreach
> registerDoParallel(1)
> resp5a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp5), stock(resp5a))
[1] "Attributes: < Component “catch”: Mean relative difference: 0.0003988964 >"     
[2] "Attributes: < Component “catch.n”: Mean relative difference: 0.0004892234 >"   
[3] "Attributes: < Component “discards”: Mean relative difference: 0.0005093035 >"  
[4] "Attributes: < Component “discards.n”: Mean relative difference: 0.0005756132 >"
[5] "Attributes: < Component “harvest”: Mean relative difference: 0.001358016 >"    
[6] "Attributes: < Component “landings”: Mean relative difference: 0.0003633235 >"  
[7] "Attributes: < Component “landings.n”: Mean relative difference: 0.000399911 >" 
[8] "Attributes: < Component “stock”: Mean relative difference: 0.0001648707 >"     
[9] "Attributes: < Component “stock.n”: Mean relative difference: 0.0001104764 >"   
> 
> # run new method in 2 cores with foreach
> registerDoParallel(3)
> resp5b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2019  > 2019  > 2020  > 2020  > 2021  > 2021  > 2018  > 2022  > 2022  > 2023  > 2023  > 2024  > 2019  > 2024  > 2025  > 2020  > 2025  > 2026  > 2021  > 2026  > 2027  > 2022  > 2027  > 2028  > 2023  > 2028  > 2029  > 2024  > 2029  > 2017  > 2025  > 2017  > 2026  > 2027  > 2018  > 2028  > 2018  > 2029  > 2019  > 2019  > 2017  > 2020  > 2021  > 2022  > 2018  > 2023  > 2019  > 2024  > 2025  > 2020  > 2021  > 2026  > 2022  > 2027  > 2020  > 2023  > 2028  > 2021  > 2024  > 2029  > 2022  > 2025  > 2017  > 2023  > 2026  > 2024  > 2027  > 2025  > 2028  > 2026  > 2029  > 2027  > 2017  > 2028  > 2029  > 2018  > 2017  > 2018  > 2019  > 2019  > 2020  > 2018  > 2021  > 2022  > 2019  > 2023  > 2020  > 2021  > 2024  > 2022  > 2025  > 2023  > 2020  > 2026  > 2024  > 2021  > 2027  > 2025  > 2022  > 2026  > 2023  > 2028  > 2027  > 2024  > 2029  > 2028  > 2025  > 2017  > 2029  > 2026  > 2027  > 2017  > 2018  > 2028  > 2029  > 2019  > 2017  > 2020  > 2018  > 2021  > 2018  > 2022  > 2019  > 2023  > 2020  > 2024  > 2021  > 2025  > 2019  > 2026  > 2022  > 2020  > 2027  > 2023  > 2021  > 2028  > 2024  > 2022  > 2025  > 2029  > 2023  > 2026  > 2017  > 2027  > 2024  > 2018  > 2025  > 2028  > 2026  > 2029  > 2019  > 2027  > 2017  > 2020  > 2028  > 2021  > 2029  > 2022  > 2023  > 2017  > 2024  > 2025  > 2018  > 2026  > 2019  > 2027  > 2020  > 2028  > 2018  > 2021  > 2029  > 2019  > 2022  > 2017  > 2020  > 2023  > 2018  > 2021  > 2024  > 2022  > 2025  > 2019  > 2023  > 2026  > 2020  > 2027  > 2024  > 2021  > 2028  > 2025  > 2022  > 2026  > 2029  > 2023  > 2027  > 2024  > 2017  > 2028  > 2025  > 2018  > 2026  > 2029  > 2027  > 2017  > 2028  > 2018  > 2029  > 2017  > 2019  > 2020  > 2018  > 2021  > 2022  > 2019  > 2023  > 2020  > 2024  > 2021  > 2025  > 2019  > 2022  > 2026  > 2023  > 2027  > 2024  > 2028  > 2025  > 2029  > 2026  > 2017  > 2027  > 2028  > 2029  > 2018  > 2017  > 2020  > 2019  > 2021  > 2020  > 2022  > 2021  > 2023  > 2022  > 2024  > 2023  > 2025  > 2024  > 2026  > 2025  > 2027  > 2026  > 2028  > 2018  > 2027  > 2029  > 2028  > 2017  > 2029  > 2018  > 2017  > 2019  > 2019  > 2020  > 2020  > 2018  > 2021  > 2021  > 2022  > 2022  > 2023  > 2023  > 2019  > 2024  > 2024  > 2025  > 2020  > 2025  > 2026  > 2021  > 2026  > 2022  > 2027  > 2027  > 2023  > 2028  > 2028  > 2024  > 2029  > 2029  > 2025  > 2017  > 2026  > 2027  > 2028  > 2029  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp5), stock(resp5b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # testing biased assessment
> #------------------------------------------------------------------------------
> biased.sa <- function(stk, idx, bbias=1, fbias=1, ...){
+ 	args <- list(...)
+ 	dy <- dimnames(catch(stk))[[2]]
+ 	dy <- dy[length(dy)]
+ 	tracking <- args$tracking
+ 	stock.n(stk)[, dy] <- stock.n(stk)[, dy]*bbias
+ 	harvest(stk)[, dy] <- harvest(stk)[, dy]*fbias
+ 	list(stk = stk, tracking = tracking)
+ }
> 
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.2)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=biased.sa, args=list(fbias=.5))))
> 
> # test parallel
> # run new method in single core without foreach
> resp6 <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with sequential foreach
> registerDoParallel(1)
> resp6a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp6), stock(resp6a))
[1] TRUE
> 
> # run new method in 2 cores with foreach
> registerDoParallel(3)
> resp6b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp6), stock(resp6b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and separable SA
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=sep.sa, args=list(fit="assessment", qmodel=list(~s(age, k=3), fmodel=~s(age, k=4) + s(year, k=20), update=FALSE)))))
> 
> # test parallel
> # run new method in single core without foreach
> resp7 <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> 
> # run new method in 1 core with sequential foreach
> registerDoParallel(1)
> resp7a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp7), stock(resp7a))
[1] "Attributes: < Component “catch”: Mean relative difference: 3.855613e-08 >"     
[2] "Attributes: < Component “catch.n”: Mean relative difference: 4.210554e-08 >"   
[3] "Attributes: < Component “discards”: Mean relative difference: 3.364647e-08 >"  
[4] "Attributes: < Component “discards.n”: Mean relative difference: 3.89652e-08 >" 
[5] "Attributes: < Component “harvest”: Mean relative difference: 5.560839e-08 >"   
[6] "Attributes: < Component “landings”: Mean relative difference: 3.825167e-08 >"  
[7] "Attributes: < Component “landings.n”: Mean relative difference: 4.141407e-08 >"
[8] "Attributes: < Component “stock”: Mean relative difference: 3.101637e-08 >"     
[9] "Attributes: < Component “stock.n”: Mean relative difference: 3.164307e-08 >"   
> 
> # run new method in 2 cores with foreach
> registerDoParallel(3)
> resp7b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !
2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2017  > 2017  > 2018  > 2018  > 2018  > 2019  > 2019  > 2019  > 2020  > 2020  > 2020  > 2021  > 2021  > 2021  > 2022  > 2022  > 2022  > 2023  > 2023  > 2023  > 2024  > 2024  > 2024  > 2025  > 2025  > 2025  > 2026  > 2026  > 2026  > 2027  > 2027  > 2027  > 2028  > 2028  > 2028  > 2029  > 2029  > 2029  > 2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> all.equal(stock(resp7), stock(resp7b))
[1] TRUE
> 
> #==============================================================================
> # Test again with cluster
> #==============================================================================
> 
> #------------------------------------------------------------------------------
> # base
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3))))
> 
> # run new method in single core without foreach
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1})
[[1]]
[1] 1

> registerDoParallel(cl)
> resp1a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp1), stock(resp1a))
[1] TRUE
> 
> # run new method in 2 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1})
[[1]]
[1] 1

[[2]]
[1] 1

[[3]]
[1] 1

> registerDoParallel(cl)
> resp1b <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> stopCluster(cl)
> all.equal(stock(resp1), stock(resp1b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(
+ 	ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is)))
> 
> # test parallel
> # run new method in single core without foreach
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1})
[[1]]
[1] 1

> registerDoParallel(cl)
> resp2a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp2), stock(resp2a))
[1] TRUE
> 
> # run new method in 3 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1})
[[1]]
[1] 1

[[2]]
[1] 1

[[3]]
[1] 1

> registerDoParallel(cl)
> resp2b <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> stopCluster(cl)
> all.equal(stock(resp2), stock(resp2b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and SA
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=sca.sa)))
> 
> # test parallel
> # run new method in single core without foreach
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> resp3a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp3), stock(resp3a))
[1] "Attributes: < Component “catch”: Mean relative difference: 1.800343e-08 >"     
[2] "Attributes: < Component “catch.n”: Mean relative difference: 2.026939e-08 >"   
[3] "Attributes: < Component “discards”: Mean relative difference: 1.736786e-08 >"  
[4] "Attributes: < Component “discards.n”: Mean relative difference: 1.962755e-08 >"
[5] "Attributes: < Component “harvest”: Mean relative difference: 2.031832e-08 >"   
[6] "Attributes: < Component “landings”: Mean relative difference: 1.738322e-08 >"  
[7] "Attributes: < Component “landings.n”: Mean relative difference: 2.019702e-08 >"
> 
> # run new method in 3 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[2]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[3]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> resp3b <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> stopCluster(cl)
> all.equal(stock(resp3), stock(resp3b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and IEM
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is)))
> 
> # test parallel
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1})
[[1]]
[1] 1

> registerDoParallel(cl)
> resp4a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp4), stock(resp4a))
[1] TRUE
> 
> # run new method in 2 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[2]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[3]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> resp4b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> all.equal(stock(resp4), stock(resp4b))
[1] TRUE
> stopCluster(cl)
> 
> #------------------------------------------------------------------------------
> # base with TAC and SA and OEM and IEM
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=sca.sa),
+ 	ctrl.tm = mseCtrl(method=mpa.tm, args=list(sel.objective=FLModelSim(model=~1/(1+exp(-(a+b*x))), params=FLPar(a=-10, b=5))))))
> 
> # test parallel
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> resp5a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp5), stock(resp5a))
[1] "Attributes: < Component “catch”: Mean relative difference: 0.0003988964 >"     
[2] "Attributes: < Component “catch.n”: Mean relative difference: 0.0004892234 >"   
[3] "Attributes: < Component “discards”: Mean relative difference: 0.0005093035 >"  
[4] "Attributes: < Component “discards.n”: Mean relative difference: 0.0005756132 >"
[5] "Attributes: < Component “harvest”: Mean relative difference: 0.001358016 >"    
[6] "Attributes: < Component “landings”: Mean relative difference: 0.0003633235 >"  
[7] "Attributes: < Component “landings.n”: Mean relative difference: 0.000399911 >" 
[8] "Attributes: < Component “stock”: Mean relative difference: 0.0001648707 >"     
[9] "Attributes: < Component “stock.n”: Mean relative difference: 0.0001104764 >"   
> 
> # run new method in 2 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[2]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[3]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> mpargs$nblocks <- 3
> resp5b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> stopCluster(cl)
> all.equal(stock(resp5), stock(resp5b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # testing biased assessment
> #------------------------------------------------------------------------------
> biased.sa <- function(stk, idx, bbias=1, fbias=1, ...){
+ 	args <- list(...)
+ 	dy <- dimnames(catch(stk))[[2]]
+ 	dy <- dy[length(dy)]
+ 	tracking <- args$tracking
+ 	stock.n(stk)[, dy] <- stock.n(stk)[, dy]*bbias
+ 	harvest(stk)[, dy] <- harvest(stk)[, dy]*fbias
+ 	list(stk = stk, tracking = tracking)
+ }
> 
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.2)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=biased.sa, args=list(fbias=.5))))
> 
> # test parallel
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> resp6a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp6), stock(resp6a))
[1] TRUE
> 
> # run new method in 2 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[2]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[3]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> mpargs$nblocks <- 3
> resp6b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> stopCluster(cl)
> all.equal(stock(resp6), stock(resp6b))
[1] TRUE
> 
> #------------------------------------------------------------------------------
> # base with TAC and separable SA
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=0.3)),
+ 	ctrl.is = mseCtrl(method=tac.is),
+ 	ctrl.est = mseCtrl(method=sep.sa, args=list(fit="assessment", qmodel=list(~s(age, k=3), fmodel=~s(age, k=4) + s(year, k=20), update=FALSE)))))
> 
> # test parallel
> cl <- makeCluster(1)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> resp7a <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > 2018  > 2019  > 2020  > 2021  > 2022  > 2023  > 2024  > 2025  > 2026  > 2027  > 2028  > 2029  > 
> stopCluster(cl)
> all.equal(stock(resp7), stock(resp7a))
[1] "Attributes: < Component “catch”: Mean relative difference: 3.855613e-08 >"     
[2] "Attributes: < Component “catch.n”: Mean relative difference: 4.210554e-08 >"   
[3] "Attributes: < Component “discards”: Mean relative difference: 3.364647e-08 >"  
[4] "Attributes: < Component “discards.n”: Mean relative difference: 3.89652e-08 >" 
[5] "Attributes: < Component “harvest”: Mean relative difference: 5.560839e-08 >"   
[6] "Attributes: < Component “landings”: Mean relative difference: 3.825167e-08 >"  
[7] "Attributes: < Component “landings.n”: Mean relative difference: 4.141407e-08 >"
[8] "Attributes: < Component “stock”: Mean relative difference: 3.101637e-08 >"     
[9] "Attributes: < Component “stock.n”: Mean relative difference: 3.164307e-08 >"   
> 
> # run new method in 2 cores with foreach
> cl <- makeCluster(3)
> clusterEvalQ(cl = cl, expr = {i <- 1;library(FLa4a)})
[[1]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[2]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

[[3]]
 [1] "FLa4a"        "latticeExtra" "RColorBrewer" "gridExtra"    "grid"        
 [6] "coda"         "copula"       "triangle"     "FLCore"       "iterators"   
[11] "lattice"      "stats"        "graphics"     "grDevices"    "utils"       
[16] "datasets"     "methods"      "base"        

> registerDoParallel(cl)
> mpargs$nblocks <- 3
> resp7b <- mp(om, oem, iem, ctrl=ctrl, args=mpargs)
Going parallel with  3  cores !

> stopCluster(cl)
> all.equal(stock(resp7), stock(resp7b))
[1] TRUE
> 
> #==============================================================================
> # Tests iters in args
> #==============================================================================
> flq <- FLQuant(c(0.3,0.2,0.4), dim=c(1,1,1,1,1,3))
> 
> #------------------------------------------------------------------------------
> # base
> #------------------------------------------------------------------------------
> ctrl <- mpCtrl(list(ctrl.hcr = mseCtrl(method=fixedF.hcr, args=list(ftrg=flq))))
> 
> #resp1 <- mp(om, oem, ctrl=ctrl, args=mpargs)
> 
> # run new method in single core without foreach
> registerDoParallel(1)
> resp1a <- mp(om, oem, ctrl=ctrl, args=mpargs)
Going single core !
2017  > Error in x@.Data[i, j, k, l, m, n] <- value : 
  number of items to replace is not a multiple of replacement length
Calls: mp -> do.call -> <Anonymous> -> [<- -> [<- -> .local
Execution halted
